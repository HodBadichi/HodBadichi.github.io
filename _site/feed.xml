<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2025-06-08T21:08:09+03:00</updated><id>http://0.0.0.0:4000/feed.xml</id><subtitle>performance networking and everything in between</subtitle><entry><title type="html">Understanding Memory Level Parallelism Through Binary Search</title><link href="http://0.0.0.0:4000/2025/06/01/memory-parallelism-modern-cpus.html" rel="alternate" type="text/html" title="Understanding Memory Level Parallelism Through Binary Search" /><published>2025-06-01T00:00:00+03:00</published><updated>2025-06-01T00:00:00+03:00</updated><id>http://0.0.0.0:4000/2025/06/01/memory-parallelism-modern-cpus</id><content type="html" xml:base="http://0.0.0.0:4000/2025/06/01/memory-parallelism-modern-cpus.html"><![CDATA[<p><strong>Code:</strong> You can find the code used for this analysis in the following GitHub repository: <a href="https://github.com/HodBadichi/Posts-Code/tree/main/19122024">Posts-Code/19122024</a></p>

<p>Beyond binary search’s $O(log n)$ complexity lies a story of CPU optimization. Modern processors don’t wait for memory they predict, prefetch, and parallelize memory operations, turning what seems like a simple algorithm into a showcase of memory level parallelism.</p>

<p>Let’s start with a standard binary search implementation:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">binary_search</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’ll use an array big enough to exceed our caches of $3.73$[GB] ($100$[m] integers) and perform $10$[m] lookups. Using Intel TMA (Top-down Microarchitecture Analysis), we can see the performance bottlenecks:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    74,870,673,648      TOPDOWN.SLOTS                    #     20.1 %  tma_backend_bound      
                                                  #     42.7 %  tma_bad_speculation    
                                                  #     33.7 %  tma_frontend_bound     
                                                  #      3.5 %  tma_retiring  
</code></pre></div></div>

<p>Only 20% of the time is spent on backend operations (including memory stalls). The majority of time (42.7%) is spent on bad speculation, which makes sense given the 50/50 branch prediction scenario in binary search.</p>

<h2 id="measuring-memory-level-parallelism">Measuring Memory Level Parallelism</h2>

<p>Unlike other performance metrics, MLP cannot be directly measured through PMU counters. Instead, best practices typically rely on either full-system simulators or analytical/partial modeling approaches to quantify MLP characteristics. There’s growing recognition of how important this metric is - for example, recent work like the MLP stack [1] helps visualize and understand MLP throughout the entire memory hierarchy.</p>

<p>One practical approach to estimate average MLP is through the following perf events:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">l1d_pend_miss.pending</code>: Total number of pending L1 data cache misses</li>
  <li><code class="language-plaintext highlighter-rouge">l1d_pend_miss.pending_cycles</code>: Total cycles with pending L1 data cache misses</li>
</ul>

<p>These metrics allow us to calculate the average MLP specifically for L1 data cache misses, which provides insight into how effectively our code utilizes memory-level parallelism at the L1 cache level:</p>

\[MLP_{avg} = \frac{l1d\_pend\_miss.pending}{l1d\_pend\_miss.pending\_cycles}\]

<p>The calculated $MLP_{avg}$ represents the average number of concurrent L1 cache misses. This value is fundamentally limited by the number of MSHRs available in the L1 data cache, which determines how many outstanding cache misses the processor can track simultaneously.</p>

<p>Analyzing our binary search implementation yields the following metrics:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    98,278,263,019      l1d_pend_miss.pending

    11,219,972,459      l1d_pend_miss.pending_cycles 
</code></pre></div></div>

<p>Calculating the average MLP:</p>

<p>$MLP_{avg} = \frac{98,278,263,019}{11,219,972,459} \approx 8.8$</p>

<p>This result highlights a crucial aspect of modern CPU performance analysis: while our binary search algorithm appears to be inherently serial, the actual MLP measurement shows significant parallelism. This discrepancy occurs because modern CPUs employ speculation techniques that can overlap memory operations, even in seemingly sequential code.</p>

<p>The observed MLP is significantly higher than the expected value of 1, which can be explained by two types of out-of-order execution:</p>

<ol>
  <li>
    <p>Function-level overlap: The CPU can execute multiple <code class="language-plaintext highlighter-rouge">binary_search()</code> calls concurrently, as these are independent operations that don’t require speculation.</p>
  </li>
  <li>
    <p>Iteration-level overlap: Within a single <code class="language-plaintext highlighter-rouge">binary_search()</code> call, the CPU overlap memory operations across different iterations.</p>
  </li>
</ol>

<p>The key distinction is that function-level overlap is deterministic (the CPU knows these operations are independent), while iteration-level overlap requires speculation (the CPU must predict which path the binary search will take).</p>

<p>To measure the impact of function-level overlap, we can use the <code class="language-plaintext highlighter-rouge">rdtscp</code> instruction as a serialization barrier, forcing the CPU to complete one query before starting the next. Running our benchmark with this modification yields:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    109,103,656,601      l1d_pend_miss.pending                                                 
     13,004,667,591      l1d_pend_miss.pending_cycles   
</code></pre></div></div>

<p>Calculating the MLP for this version:
\(MLP_{avg} = \frac{109,103,656,601}{13,004,667,591} \approx 8.39\)</p>

<p>This result is particularly interesting: despite using a serialization barrier, the MLP only decreased by about 5% from our original measurement. This suggests that function-level overlap contributes less to our observed MLP than we might have expected, indicating that most of the parallelism comes from iteration-level overlap within each binary search operation.</p>

<p>Running a branchless version we will be able to verify the MLP comes from speculation:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">binary_search_branchless</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">half</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">base</span> <span class="o">+=</span> <span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">half</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="o">*</span> <span class="n">half</span><span class="p">;</span>
        <span class="n">len</span> <span class="o">-=</span> <span class="n">half</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">base</span> <span class="o">-</span> <span class="n">arr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and indeed we get  MLP of 1.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    14,443,856,192      l1d_pend_miss.pending                                                 
    14,418,507,045      l1d_pend_miss.pending_cycles  
</code></pre></div></div>

<h3 id="mlp-limitations">MLP limitations</h3>

<p>MLP is constrained by two main factors:</p>

<ol>
  <li>Hardware limitations:
    <ul>
      <li>Reorder Buffer (ROB) size: Determines how many instructions can be in-flight</li>
      <li>Number of MSHRs (Miss Status Holding Registers): Limits concurrent cache misses</li>
    </ul>
  </li>
  <li>Program characteristics:
    <ul>
      <li>Load clustering: How memory accesses are distributed</li>
      <li>Out-of-order opportunities: Sequential dependencies (like pointer chasing) limit parallel execution</li>
      <li>Speculation opportunities: Whether the code allows for effective branch prediction</li>
    </ul>
  </li>
</ol>

<p>In our binary search example, we observed an MLP of 8. This value reveals several insights:</p>
<ul>
  <li>The MSHR limit isn’t the bottleneck (Intel Sapphire Rapids supports 16 MSHRs)</li>
  <li>The observed MLP of 8 suggests the limiting factors are:
    <ul>
      <li>ROB size constraints</li>
      <li>Limited speculation depth beyond L1 cache</li>
    </ul>
  </li>
</ul>

<p>Honestly, without a detailed microarchitecture simulator, it’s pretty hard to say exactly why our MLP isn’t maxing out the MSHRs. A full-on simulator would probably be able to figure it out, though.</p>

<h2 id="references">References</h2>

<p><a name="ref1"></a>[1] <strong>MLP Visualizer Tool</strong>: <a href="https://www.linkedin.com/posts/shoaib-akram-58999211b_efficient-exploitation-of-memory-level-parallelism-activity-7314176717437210624-pQt3/">Depicting the MLP stack</a></p>

<p>[2] <strong>Andrew Glew</strong>: <a href="https://people.eecs.berkeley.edu/~kubitron/asplos98/abstracts/andrew_glew.pdf">MLP: Yes, There is a Free Lunch</a> - ASPLOS 1998</p>

<p>[3] <strong>Intel Performance Monitoring Events</strong>: <a href="https://perfmon-events.intel.com/spxeon.html">Sapphire Rapids Performance Monitoring</a></p>

<p>[4] <strong>Daniel Lemire’s Blog</strong>: <a href="https://lemire.me/blog/tag/mlp/">Memory Level Parallelism showcase</a></p>]]></content><author><name></name></author><category term="cpu-architecture" /><category term="performance" /><category term="memory" /><category term="hardware" /><summary type="html"><![CDATA[Beyond binary search's $O(log n)$ complexity lies a story of CPU optimization. Modern processors don't wait for memory they predict, prefetch, and parallelize memory operations, turning what seems like a simple algorithm into a showcase of memory level parallelism.]]></summary></entry></feed>